---
title: "Simulation Challenge"
subtitle: "Generative Models and Monte Carlo Simulation"
format:
  html: default
  pdf: default
execute:
  echo: true
  eval: true
---

# ðŸŽ² Simulation Challenge - Monte Carlo Analysis


**Your Mission:** Create a comprehensive Quarto document that simulates one or two investment strategies, analyzes the results, and demonstrates your ability to present counter-intuitive findings compellingly. Then render the document to HTML and deploy it via GitHub Pages from a new repository called "simulationChallenge."



*Remember: Frequent commits are your safety net!*
:::

## R Pathway Solution ðŸŽ¯

This section provides a complete R implementation for all challenge questions. You can use this as a reference or starting point for your own analysis.

### Setup and Libraries

```{r}
#| label: setup
#| echo: true

# Load required libraries
suppressPackageStartupMessages({
  library(tidyverse)
  library(ggplot2)
  library(scales)
})

# Set seed for reproducibility
set.seed(123)
```

### Question 1: Expected Value Analysis

```{r}
#| label: expected-value
#| echo: true
#| fig-cap: Expected value calculation for the investment game

# Parameters for the original game
initial_wealth <- 1000
heads_multiplier <- 1.5  # +50% gain
tails_multiplier <- 0.6  # -40% loss
probability_heads <- 0.5

# Calculate expected value after one coin flip
expected_value_one_flip <- probability_heads * (initial_wealth * heads_multiplier) + 
                          (1 - probability_heads) * (initial_wealth * tails_multiplier)

# Calculate expected return rate
expected_return_rate <- (expected_value_one_flip - initial_wealth) / initial_wealth

cat("Expected value after 1 coin flip: $", round(expected_value_one_flip, 2), "\n")
cat("Expected return rate: ", round(expected_return_rate * 100, 2), "%\n")
cat("Is expected value positive? ", expected_value_one_flip > initial_wealth, "\n")
```

### Question 2: Expectation vs. Reality Analysis

```{r}
#| label: expectation-analysis
#| echo: true

cat("ANALYSIS:\n")
cat("=========\n")
cat("Expected value: $", round(expected_value_one_flip, 2), "\n")
cat("Initial wealth: $", initial_wealth, "\n")
cat("Difference: $", round(expected_value_one_flip - initial_wealth, 2), "\n\n")

if (expected_value_one_flip > initial_wealth) {
  cat("The expected value is POSITIVE, suggesting the game is favorable.\n")
  cat("However, this is misleading because it doesn't account for the multiplicative nature of the game.\n")
  cat("In reality, the geometric mean return is what matters for long-term wealth growth.\n")
} else {
  cat("The expected value is NEGATIVE, suggesting the game is unfavorable.\n")
}

# Calculate geometric mean return
geometric_mean_return <- sqrt(heads_multiplier * tails_multiplier)
cat("\nGeometric mean return per flip:", round(geometric_mean_return, 4), "\n")
cat("This means wealth will DECLINE over time (geometric mean < 1)\n")
```

### Question 3: Single Simulation

```{r}
#| label: single-simulation
#| echo: true
#| fig-cap: Single simulation showing wealth evolution over time

# Function to simulate one path
simulate_investment_path <- function(initial_wealth, n_periods, heads_mult, tails_mult) {
  wealth <- initial_wealth
  path <- numeric(n_periods + 1)
  path[1] <- initial_wealth
  
  for (i in 1:n_periods) {
    coin_flip <- rbinom(1, 1, 0.5)
    if (coin_flip == 1) {
      wealth <- wealth * heads_mult
    } else {
      wealth <- wealth * tails_mult
    }
    path[i + 1] <- wealth
  }
  
  return(path)
}

# Simulate one path (assuming 35 years from age 20 to 55)
n_periods <- 35
single_path <- simulate_investment_path(initial_wealth, n_periods, heads_multiplier, tails_multiplier)

# Create data frame for plotting
simulation_data <- tibble(
  age = 20:(20 + n_periods),
  wealth = single_path
)

# Create time series plot
ggplot(simulation_data, aes(x = age, y = wealth)) +
  geom_line(color = "steelblue", linewidth = 1.2) +
  geom_point(color = "darkblue", size = 2) +
  geom_hline(yintercept = initial_wealth, color = "red", linetype = "dashed", linewidth = 1) +
  labs(
    title = "Investment Game: Single Simulation Path",
    subtitle = "Wealth Evolution from Age 20 to 55",
    x = "Age",
    y = "Account Balance ($)",
    caption = "Red line shows initial investment ($1,000)"
  ) +
  scale_y_continuous(labels = dollar_format()) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12, color = "gray50"),
    axis.text = element_text(size = 10)
  )

# Show final results
cat("SINGLE SIMULATION RESULTS:\n")
cat("==========================\n")
cat("Initial wealth: $", initial_wealth, "\n")
cat("Final wealth: $", round(single_path[length(single_path)], 2), "\n")
cat("Total return: ", round((single_path[length(single_path)] / initial_wealth - 1) * 100, 2), "%\n")
cat("Are you happy? ", ifelse(single_path[length(single_path)] > initial_wealth, "YES!", "NO..."), "\n")
```

### Question 4: Multiple Simulations (100 runs)

```{r}
#| label: multiple-simulations
#| echo: true
#| fig-cap: Distribution of final wealth from 100 simulations

# Run 100 simulations
n_simulations <- 100
final_wealths <- numeric(n_simulations)

for (i in 1:n_simulations) {
  path <- simulate_investment_path(initial_wealth, n_periods, heads_multiplier, tails_multiplier)
  final_wealths[i] <- path[length(path)]
}

# Create data frame for analysis
simulation_results <- tibble(
  simulation = 1:n_simulations,
  final_wealth = final_wealths
)

# Create histogram
ggplot(simulation_results, aes(x = final_wealth)) +
  geom_histogram(bins = 20, fill = "lightcoral", alpha = 0.8, color = "black") +
  geom_vline(xintercept = initial_wealth, color = "red", linetype = "dashed", linewidth = 1.5) +
  geom_vline(xintercept = mean(final_wealths), color = "blue", linetype = "solid", linewidth = 1) +
  labs(
    title = "Distribution of Final Wealth (100 Simulations)",
    subtitle = "Investment Game from Age 20 to 55",
    x = "Final Wealth ($)",
    y = "Frequency",
    caption = "Red line: Initial investment ($1,000)\nBlue line: Mean final wealth"
  ) +
  scale_x_continuous(labels = dollar_format(), trans = "log10") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12, color = "gray50")
  )

# Summary statistics
summary_stats <- simulation_results %>%
  summarise(
    mean_wealth = mean(final_wealth),
    median_wealth = median(final_wealth),
    min_wealth = min(final_wealth),
    max_wealth = max(final_wealth),
    prob_above_initial = mean(final_wealth > initial_wealth)
  )

cat("MULTIPLE SIMULATIONS RESULTS (100 runs):\n")
cat("========================================\n")
print(summary_stats)

cat("\nAre you happy with these results?\n")
cat("The median wealth is $", round(median(final_wealths), 2), 
    " which is ", ifelse(median(final_wealths) > initial_wealth, "above", "below"), 
    " the initial investment.\n")
cat("Only ", round(mean(final_wealths > initial_wealth) * 100, 1), 
    "% of simulations resulted in wealth above the initial $1,000.\n")
```

### Question 5: Probability Analysis

```{r}
#| label: probability-analysis
#| echo: true

# Calculate probability of wealth > $1,000 at age 55
prob_above_1000 <- mean(final_wealths > 1000)

cat("PROBABILITY ANALYSIS:\n")
cat("====================\n")
cat("Probability of wealth > $1,000 at age 55: ", round(prob_above_1000, 3), "\n")
cat("This means there's a ", round(prob_above_1000 * 100, 1), 
    "% chance of having more than your initial investment.\n")
cat("Conversely, there's a ", round((1 - prob_above_1000) * 100, 1), 
    "% chance of losing money.\n")

# Additional probability insights
prob_above_5000 <- mean(final_wealths > 5000)
prob_above_10000 <- mean(final_wealths > 10000)

cat("\nAdditional probabilities:\n")
cat("P(wealth > $5,000): ", round(prob_above_5000, 3), "\n")
cat("P(wealth > $10,000): ", round(prob_above_10000, 3), "\n")
```

### Question 6: Modified Strategy Comparison

```{r}
#| label: modified-strategy
#| echo: true
#| fig-cap: Comparison between original and modified strategies

# Modified strategy: bet exactly 50% of current balance each time
simulate_modified_strategy <- function(initial_wealth, n_periods) {
  wealth <- initial_wealth
  path <- numeric(n_periods + 1)
  path[1] <- initial_wealth
  
  for (i in 1:n_periods) {
    # Bet exactly 50% of current wealth
    bet_amount <- wealth * 0.5
    remaining_wealth <- wealth - bet_amount
    
    coin_flip <- rbinom(1, 1, 0.5)
    if (coin_flip == 1) {
      # Win: bet increases by 50%
      bet_result <- bet_amount * 1.5
    } else {
      # Lose: bet decreases by 40%
      bet_result <- bet_amount * 0.6
    }
    
    wealth <- remaining_wealth + bet_result
    path[i + 1] <- wealth
  }
  
  return(path)
}

# Run 100 simulations for modified strategy
modified_final_wealths <- numeric(n_simulations)

for (i in 1:n_simulations) {
  path <- simulate_modified_strategy(initial_wealth, n_periods)
  modified_final_wealths[i] <- path[length(path)]
}

# Create comparison data frame
comparison_data <- tibble(
  strategy = rep(c("Original", "Modified"), each = n_simulations),
  final_wealth = c(final_wealths, modified_final_wealths)
)

# Create comparison plot
ggplot(comparison_data, aes(x = final_wealth, fill = strategy)) +
  geom_histogram(alpha = 0.7, bins = 20, position = "identity") +
  geom_vline(xintercept = 1000, color = "red", linetype = "dashed", linewidth = 1) +
  geom_vline(xintercept = 10000, color = "green", linetype = "dashed", linewidth = 1) +
  facet_wrap(~strategy, ncol = 1) +
  labs(
    title = "Strategy Comparison: Final Wealth Distributions",
    subtitle = "Original vs Modified Investment Strategies",
    x = "Final Wealth ($)",
    y = "Frequency",
    caption = "Red line: $1,000 threshold\nGreen line: $10,000 threshold"
  ) +
  scale_x_continuous(labels = dollar_format(), trans = "log10") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12, color = "gray50"),
    legend.position = "none"
  )

# Calculate probabilities for modified strategy
prob_above_1000_modified <- mean(modified_final_wealths > 1000)
prob_above_10000_modified <- mean(modified_final_wealths > 10000)

cat("MODIFIED STRATEGY COMPARISON:\n")
cat("============================\n")
cat("Original Strategy:\n")
cat("  P(wealth > $1,000): ", round(prob_above_1000, 3), "\n")
cat("  P(wealth > $10,000): ", round(prob_above_10000, 3), "\n\n")

cat("Modified Strategy:\n")
cat("  P(wealth > $1,000): ", round(prob_above_1000_modified, 3), "\n")
cat("  P(wealth > $10,000): ", round(prob_above_10000_modified, 3), "\n\n")

cat("COMPARISON:\n")
cat("P(wealth > $10,000) is ", 
    ifelse(prob_above_10000_modified > prob_above_10000, "HIGHER", "LOWER"), 
    " in the modified strategy.\n")
cat("Difference: ", round((prob_above_10000_modified - prob_above_10000) * 100, 1), " percentage points\n")
```

### Summary and Insights

```{r}
#| label: summary-insights
#| echo: true

cat("KEY INSIGHTS FROM THE SIMULATION:\n")
cat("=================================\n\n")

cat("1. EXPECTED VALUE DECEPTION:\n")
cat("   - Expected value suggests the game is favorable\n")
cat("   - But geometric mean shows wealth will decline over time\n")
cat("   - This is a classic example of why expected value can be misleading\n\n")

cat("2. PROBABILITY OF SUCCESS:\n")
cat("   - Only ", round(prob_above_1000 * 100, 1), "% chance of beating initial investment\n")
cat("   - ", round((1 - prob_above_1000) * 100, 1), "% chance of losing money\n\n")

cat("3. STRATEGY COMPARISON:\n")
cat("   - Modified strategy (betting 50%) shows different risk profile\n")
cat("   - P(wealth > $10,000): Original = ", round(prob_above_10000, 3), 
    ", Modified = ", round(prob_above_10000_modified, 3), "\n\n")

cat("4. SIMULATION WISDOM:\n")
cat("   - Simulation reveals the true nature of multiplicative processes\n")
cat("   - Intuition often fails with compound effects\n")
cat("   - Always run simulations to understand complex systems!\n")
```

## Essential Simulation Concepts ðŸŽ¯ {#sec-simulation-concepts}

Before diving into the challenge, let's review the key simulation concepts you'll need. These examples will prepare you for the investment game analysis.

### 1. Simple Simulation: Coin Flip Game

Let's start with a basic coin flip simulation to understand the mechanics:


::: {.panel-tabset}

### R

```{r}
#| label: simple-sim-r
#| fig-cap: R simulation of coin flip game
#| echo: true

suppressPackageStartupMessages(library(tidyverse))

# Set seed for reproducibility
set.seed(123)

# Number of simulations
n_sims <- 10

# Create simulation data
sim_data <- tibble(
  sim_num = 1:n_sims,
  coin_flip = rbinom(n = n_sims, size = 1, prob = 0.5)
) %>%
  mutate(
    winnings = if_else(coin_flip == 1, 100, -100)
  )

# Display results
sim_data
```

### Python

```{python}
#| label: simple-sim-python
#| fig-cap: Python simulation of coin flip game
#| echo: true

import numpy as np
import pandas as pd

# Set seed for reproducibility
np.random.seed(123)

# Number of simulations
n_sims = 10

# Step 1: Draw coin flips (stochastic node)
X = np.random.binomial(n=1, p=0.5, size=n_sims)

# Step 2: Compute winnings (deterministic node)
W = np.where(X == 1, 100, -100)

# Combine into data frame
sim_data = pd.DataFrame({
    'sim_num': range(1, n_sims + 1),
    'coin_flip': X,
    'winnings': W
})

# Display results
sim_data
```

:::

### 2. Time-Series Simulation: Account Balance Over Time

Now let's simulate how an account balance changes over multiple periods:


::: {.panel-tabset}

### R

```{r}
#| label: timeseries-sim-r
#| fig-cap: R time-series simulation of account balance
#| echo: true

suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(ggplot2))

# Set seed for reproducibility
set.seed(456)

# Parameters
initial_balance <- 1000
n_periods <- 10
n_sims <- 1  # Start with one simulation

# Simulate one path
simulate_path <- function(initial, periods) {
  balance <- initial
  path <- numeric(periods + 1)
  path[1] <- initial
  
  for (i in 1:periods) {
    coin_flip <- rbinom(1, 1, 0.5)
    if (coin_flip == 1) {
      balance <- balance + 100
    } else {
      balance <- balance - 100
    }
    path[i + 1] <- balance
  }
  
  return(path)
}

# Run simulation
time_series_data <- tibble(
  period = 0:n_periods,
  balance = simulate_path(initial_balance, n_periods)
)

# Create time series plot
ggplot(time_series_data, aes(x = period, y = balance)) +
  geom_line(color = "cadetblue", linewidth = 1.2) +
  geom_point(color = "darkblue", size = 2) +
  labs(
    title = "Account Balance Over Time",
    subtitle = "Single Simulation Path",
    x = "Period",
    y = "Account Balance ($)",
    caption = "Heads: +$100$, Tails: -$100$"
  ) +
  scale_y_continuous(labels = scales::dollar_format()) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12, color = "gray50")
  )

# Show the data
time_series_data
```

### Python

```{python}
#| label: timeseries-sim-python
#| fig-cap: Python time-series simulation of account balance
#| echo: true

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(456)

# Parameters
initial_balance = 1000
n_periods = 10
n_sims = 1  # Start with one simulation

# Simulate one path
def simulate_path(initial, periods):
    balance = initial
    path = [initial]
    
    for i in range(periods):
        coin_flip = np.random.binomial(1, 0.5)
        if coin_flip == 1:
            balance = balance + 100  # $100 gain
        else:
            balance = balance - 100  # $100 loss
        path.append(balance)
    
    return path

# Run simulation
time_series_data = pd.DataFrame({
    'period': range(n_periods + 1),
    'balance': simulate_path(initial_balance, n_periods)
})

# Create time series plot
fig, ax = plt.subplots(figsize=(10, 6))
ax.plot(time_series_data['period'], time_series_data['balance'], 
        color='cadetblue', linewidth=2, marker='o', markersize=6)
ax.set_title('Account Balance Over Time\nSingle Simulation Path', 
             fontsize=14, fontweight='bold')
ax.set_xlabel('Period', fontsize=12)
ax.set_ylabel('Account Balance ($)', fontsize=12)
ax.grid(True, alpha=0.3)
ax.set_ylim(0, max(time_series_data['balance']) * 1.1)

# Format y-axis as currency
ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

plt.tight_layout()
plt.show()

# Show the data
print("Time Series Data:")
print(time_series_data)
```

:::

### 3. Probability Distribution: Final Balance Distribution

Let's see what the distribution of final balances looks like across many simulations:

::: {.panel-tabset}

### R

```{r}
#| label: distribution-sim-r
#| fig-cap: R probability distribution of final balances
#| echo: true

suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(ggplot2))

# Set seed for reproducibility
set.seed(789)

# Parameters
initial_balance <- 1000
n_periods <- 10
n_sims <- 100  # Multiple simulations

# Simulate multiple paths
simulate_final_balance <- function(initial, periods) {
  balance <- initial
  for (i in 1:periods) {
    coin_flip <- rbinom(1, 1, 0.5)
    if (coin_flip == 1) {
      balance <- balance + 100  # $100 gain
    } else {
      balance <- balance - 100  # $100 loss
    }
  }
  return(balance)
}

# Run multiple simulations
final_balances <- replicate(n_sims, simulate_final_balance(initial_balance, n_periods))

# Create data frame
distribution_data <- tibble(
  sim_num = 1:n_sims,
  final_balance = final_balances
)

# Create histogram
ggplot(distribution_data, aes(x = final_balance)) +
  geom_histogram(bins = 20, fill = "plum", alpha = 0.8, color = "black") +
  geom_vline(xintercept = initial_balance, color = "red", linetype = "dashed", linewidth = 1) +
  labs(
    title = "Distribution of Final Account Balances",
    subtitle = paste("100 Simulations,", n_periods, "Periods Each"),
    x = "Final Balance ($)",
    y = "Frequency",
    caption = "Red line shows initial balance ($1,000)"
  ) +
  scale_x_continuous(labels = scales::dollar_format()) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12, color = "gray50")
  )

# Summary statistics
summary_stats <- distribution_data %>%
  summarise(
    mean_balance = mean(final_balance),
    median_balance = median(final_balance),
    prob_above_initial = mean(final_balance > initial_balance)
  )

print("Summary Statistics:")
summary_stats
```

### Python

```{python}
#| label: distribution-sim-python
#| fig-cap: Python probability distribution of final balances
#| echo: true

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(789)

# Parameters
initial_balance = 1000
n_periods = 10
n_sims = 100  # Multiple simulations

# Simulate multiple paths
def simulate_final_balance(initial, periods):
    balance = initial
    for i in range(periods):
        coin_flip = np.random.binomial(1, 0.5)
        if coin_flip == 1:
            balance = balance + 100  # $100 gain
        else:
            balance = balance - 100  # $100 loss
    return balance

# Run multiple simulations
final_balances = [simulate_final_balance(initial_balance, n_periods) for _ in range(n_sims)]

# Create data frame
distribution_data = pd.DataFrame({
    'sim_num': range(1, n_sims + 1),
    'final_balance': final_balances
})

# Create histogram
fig, ax = plt.subplots(figsize=(10, 6))
ax.hist(distribution_data['final_balance'], bins=20, color='plum', alpha=0.8, edgecolor='black')
ax.axvline(initial_balance, color='red', linestyle='--', linewidth=2, label='Initial Balance')
ax.set_title(f'Distribution of Final Account Balances\n100 Simulations, {n_periods} Periods Each', 
             fontsize=14, fontweight='bold')
ax.set_xlabel('Final Balance ($)', fontsize=12)
ax.set_ylabel('Frequency', fontsize=12)
ax.legend()
ax.grid(True, alpha=0.3)

# Format x-axis as currency
ax.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

plt.tight_layout()
plt.show()

# Summary statistics
mean_balance = distribution_data['final_balance'].mean()
median_balance = distribution_data['final_balance'].median()
prob_above_initial = (distribution_data['final_balance'] > initial_balance).mean()

print("Summary Statistics:")
print(f"Mean balance: ${mean_balance:,.2f}")
print(f"Median balance: ${median_balance:,.2f}")
print(f"Probability above initial: {prob_above_initial:.3f}")
```

:::